<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>UDP打洞理论及实现 | Akejyo-bolg</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/blog/HP/logo-nav.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <meta name="description" content="">
    
    <link rel="preload" href="/blog/assets/css/0.styles.7e6ff6a1.css" as="style"><link rel="preload" href="/blog/assets/js/app.10530e5b.js" as="script"><link rel="preload" href="/blog/assets/js/7.3944018b.js" as="script"><link rel="preload" href="/blog/assets/js/71.2c3d7701.js" as="script"><link rel="preload" href="/blog/assets/js/4.bcd292e7.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.e84896b2.js"><link rel="prefetch" href="/blog/assets/js/11.58cc8d34.js"><link rel="prefetch" href="/blog/assets/js/12.f13297e1.js"><link rel="prefetch" href="/blog/assets/js/13.8814e4cf.js"><link rel="prefetch" href="/blog/assets/js/14.8db0c612.js"><link rel="prefetch" href="/blog/assets/js/15.a16117b8.js"><link rel="prefetch" href="/blog/assets/js/16.2ce801eb.js"><link rel="prefetch" href="/blog/assets/js/17.92b6c2d6.js"><link rel="prefetch" href="/blog/assets/js/18.246f49ec.js"><link rel="prefetch" href="/blog/assets/js/19.bf52017f.js"><link rel="prefetch" href="/blog/assets/js/2.23f5757f.js"><link rel="prefetch" href="/blog/assets/js/20.2c61a476.js"><link rel="prefetch" href="/blog/assets/js/21.95161752.js"><link rel="prefetch" href="/blog/assets/js/22.3d64a7d0.js"><link rel="prefetch" href="/blog/assets/js/23.fd64066b.js"><link rel="prefetch" href="/blog/assets/js/24.c221315b.js"><link rel="prefetch" href="/blog/assets/js/25.a3c49f47.js"><link rel="prefetch" href="/blog/assets/js/26.fa47475f.js"><link rel="prefetch" href="/blog/assets/js/27.cc46748a.js"><link rel="prefetch" href="/blog/assets/js/28.6449a686.js"><link rel="prefetch" href="/blog/assets/js/29.6166c3d9.js"><link rel="prefetch" href="/blog/assets/js/3.cb12477a.js"><link rel="prefetch" href="/blog/assets/js/30.972d9d0e.js"><link rel="prefetch" href="/blog/assets/js/31.57e81435.js"><link rel="prefetch" href="/blog/assets/js/32.e8e65424.js"><link rel="prefetch" href="/blog/assets/js/33.e3f83f53.js"><link rel="prefetch" href="/blog/assets/js/34.6a4b71bf.js"><link rel="prefetch" href="/blog/assets/js/35.ceafe2cd.js"><link rel="prefetch" href="/blog/assets/js/36.e8342154.js"><link rel="prefetch" href="/blog/assets/js/37.4cfe3598.js"><link rel="prefetch" href="/blog/assets/js/38.65fda662.js"><link rel="prefetch" href="/blog/assets/js/39.45d5da3c.js"><link rel="prefetch" href="/blog/assets/js/40.95a89642.js"><link rel="prefetch" href="/blog/assets/js/41.2c4a78ca.js"><link rel="prefetch" href="/blog/assets/js/42.3ecf1fdb.js"><link rel="prefetch" href="/blog/assets/js/43.86b79842.js"><link rel="prefetch" href="/blog/assets/js/44.0b4f7ef4.js"><link rel="prefetch" href="/blog/assets/js/45.0f0a5b88.js"><link rel="prefetch" href="/blog/assets/js/46.1a47a1a3.js"><link rel="prefetch" href="/blog/assets/js/47.21c3b18b.js"><link rel="prefetch" href="/blog/assets/js/48.04adba19.js"><link rel="prefetch" href="/blog/assets/js/49.3a9e669c.js"><link rel="prefetch" href="/blog/assets/js/5.c472a316.js"><link rel="prefetch" href="/blog/assets/js/50.b659aae6.js"><link rel="prefetch" href="/blog/assets/js/51.6d144a5e.js"><link rel="prefetch" href="/blog/assets/js/52.c5cccc0a.js"><link rel="prefetch" href="/blog/assets/js/53.ceda580a.js"><link rel="prefetch" href="/blog/assets/js/54.ff5d303e.js"><link rel="prefetch" href="/blog/assets/js/55.636c12ba.js"><link rel="prefetch" href="/blog/assets/js/56.6dfdc6a0.js"><link rel="prefetch" href="/blog/assets/js/57.4fe2dc90.js"><link rel="prefetch" href="/blog/assets/js/58.43e2f095.js"><link rel="prefetch" href="/blog/assets/js/59.20472e59.js"><link rel="prefetch" href="/blog/assets/js/6.1454379f.js"><link rel="prefetch" href="/blog/assets/js/60.bf130f9c.js"><link rel="prefetch" href="/blog/assets/js/61.0dbc324c.js"><link rel="prefetch" href="/blog/assets/js/62.3c327d75.js"><link rel="prefetch" href="/blog/assets/js/63.18307000.js"><link rel="prefetch" href="/blog/assets/js/64.202854be.js"><link rel="prefetch" href="/blog/assets/js/65.72b47f55.js"><link rel="prefetch" href="/blog/assets/js/66.2fbc53c6.js"><link rel="prefetch" href="/blog/assets/js/67.c7818724.js"><link rel="prefetch" href="/blog/assets/js/68.da91b0f0.js"><link rel="prefetch" href="/blog/assets/js/69.ec9f0a50.js"><link rel="prefetch" href="/blog/assets/js/70.4ddb1360.js"><link rel="prefetch" href="/blog/assets/js/72.339854a5.js"><link rel="prefetch" href="/blog/assets/js/73.9f71d845.js"><link rel="prefetch" href="/blog/assets/js/8.2d0a2e85.js"><link rel="prefetch" href="/blog/assets/js/9.e72484c0.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.7e6ff6a1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout" data-v-7f2e4136><header class="header-container" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/blog/HP/p3.JPG);" data-v-93921ff8 data-v-7f2e4136><nav class="navbar" style="position:absolute;opacity:1;transition:all 0.5s ease-in-out;" data-v-93921ff8><a href="/blog/" class="navbar-link router-link-active">
    Akejyo Blog
  </a> <ul class="navbar-links"><li><a href="/blog/" class="router-link-active">
        Home
      </a></li><li><a href="/blog/about/">
        ABOUT
      </a></li><li><a href="/blog/tags/">
        TAGS
      </a></li></ul> <div id="nav-icon"><span></span><span></span><span></span></div></nav> <div class="header-title" data-v-93921ff8 data-v-93921ff8><h1 data-v-93921ff8>UDP打洞理论及实现</h1> <p data-v-93921ff8></p></div></header> <div class="container" data-v-b3fda33c data-v-7f2e4136><main class="main" style="width:60%;" data-v-b3fda33c><div class="post" data-v-b3fda33c data-v-b3fda33c><article class="main-div"><div class="post-content content content__default"><h1 id="udp打洞理论及实现"><a href="#udp打洞理论及实现" class="header-anchor">#</a> UDP打洞理论及实现</h1> <h3 id="_1-1-nat简介"><a href="#_1-1-nat简介" class="header-anchor">#</a> 1.1 NAT简介</h3> <p>NAT（Network Address Translation，网络地址转换），是一种在IP数据包通过路由器或防火墙时重写IP地址或目的IP地址的技术。这种技术使得多台主机可以通过一个共有IP地址访问互联网的私有网络中，解决了IPv4地址短缺的问题[2]。</p> <h3 id="_1-2-p2p简介"><a href="#_1-2-p2p简介" class="header-anchor">#</a> 1.2 P2P简介</h3> <p>P2P（peer-to-peer，对等式网络、点对点技术），是一种去中心化、依靠用户 群交换信息的互联网体系。P2P使得人们通过互联网直接联系起来，用户可以直接连接到其他用户的计算机来交换文件，而不是连接浏览器去下载[3]。</p> <h3 id="_1-3-udp"><a href="#_1-3-udp" class="header-anchor">#</a> 1.3 UDP</h3> <h4 id="_1-3-1-udp简介"><a href="#_1-3-1-udp简介" class="header-anchor">#</a> 1.3.1 UDP简介</h4> <p>UDP（User Datagram Protocol，用户数据包协议），是一种面向数据包的通信协议，只提供数据的不可靠传递。UDP适用于对时间要求高、可以容忍数据丢包的应用[4]。</p> <h4 id="_1-3-2-udp打洞技术的意义"><a href="#_1-3-2-udp打洞技术的意义" class="header-anchor">#</a> 1.3.2 UDP打洞技术的意义</h4> <p>由于NAT的存在，NAT对于发送过来的消息，只会接收存在对应映射表的数据。假设NAT A下的设备1想与NAT B下的设备2通信，在此之前二者没有联络过，设备1向NAT B的公网地址通信，但NAT B并没有来自NAT A的映射，于是NAT B会直接将数据包丢弃。这就需要UDP打洞来穿透NAT。</p> <h2 id="第二章-系统分析"><a href="#第二章-系统分析" class="header-anchor">#</a> 第二章 系统分析</h2> <h3 id="_2-1-nat的类型分析"><a href="#_2-1-nat的类型分析" class="header-anchor">#</a> 2.1 NAT的类型分析</h3> <p>NAT有多种类型，类型的不同会影响到能否进行UDP打洞以及打洞的方式。下面是各种NAT类型的介绍。</p> <p>假设内部主机A的端口Port_A通过NAT设备的外网端口Port_nat映射到外部主机B地址的端口Port_B（A:Port_A→Port_nat→B:Port_B）：</p> <ol><li><p>完全圆锥型NAT（Full cone NAT,即NAT1），任何外部主机都可以通过Port_nat向主机A发送数据，NAT设备无条件将Port_nat收到的数据转发给Port_A。</p></li> <li><p>受限圆锥型NAT（Address-Restricted cone NAT，即NAT2），相比于NAT1，只有来自主机B的数据才会被转发。</p></li> <li><p>端口受限圆锥型NAT（Port-Restricted once NAT，即NAT3），相比于NAT1，只有来自主机B的Port_B端口的数据才会被转发。</p></li> <li><p>对称NAT（Symmetric NAT，即NAT4），NAT4的受限特性与NAT3一样。</p></li></ol> <p>对于圆锥型NAT（NAT1-NAT3），只要内部主机A继续用Port_A发送数据，该数据端口经过NAT设备映射后都会转变成一个固定不变的端口；而在对称性NAT中，如果发送目标的IP或端口改变，NAT设备会使用一个新端口重新建立一个映射关系。</p> <h3 id="_2-2-udp打洞方式分析"><a href="#_2-2-udp打洞方式分析" class="header-anchor">#</a> 2.2 UDP打洞方式分析</h3> <p>设有客户端A和B，服务器S；A的NAT设备为NAT_A，B的NAT设备为NAT_B；A的IP和端口为ip_A和port_A，B的IP和端口为ip_B和port_B；A的数据经过NAT_A的映射的IP和端口为ip_NA和port_NA，B的数据经过NAT_B的映射的IP和端口为ip_NB和port_NB：</p> <h4 id="_2-2-1-连接双方都是圆锥型nat"><a href="#_2-2-1-连接双方都是圆锥型nat" class="header-anchor">#</a> 2.2.1 连接双方都是圆锥型NAT</h4> <ol><li>A向S发送任意数据，S获取数据的同时会获得由NAT_A转换的ip_NA和port_NA；B进行同样操作；</li></ol> <img src="/blog/udp/1.png"> <p>​																				图2-1</p> <p>​											（蓝色为发送的数据，括号内数字代表次序）</p> <p>在收到A,B的数据后，将ip_NA和port_NA发给B，将ip_NB和port_NB发送给A；</p> <ol start="2"><li><p>A向ip_NB:port_NB发送任意数据，根据NAT的要求，由于NAT_B里没有与A的通信记录（映射表），NAT_B会直接将该数据丢弃。而NAT_A此时建立了到NAT_B的映射表，之后将允许NAT_B发送消息过来；</p></li> <li><p>B向ip_NA:port_NA发送任意数据，由3可得，A可以接受到信息，此时A再向B发送连接成功的信息，打洞完成，A和B可以直接通信。</p></li></ol> <img src="/blog/udp/2.png"> <p>​																					图2-2</p> <p>​																（箭头表示发送的目标地址）</p> <h4 id="_2-2-2-一方为nat4-一方为nat1-nat2"><a href="#_2-2-2-一方为nat4-一方为nat1-nat2" class="header-anchor">#</a> 2.2.2 一方为NAT4，一方为NAT1/NAT2</h4> <p>与前一种情况类似，但是需要NAT1/NAT2方的设备执行打洞操作。NAT4由于其特性，当发送目标改变后会改变自身内部地址的映射，导致无法建立联系。</p> <h4 id="_2-2-3-一方为nat4-一方为nat3-nat4"><a href="#_2-2-3-一方为nat4-一方为nat3-nat4" class="header-anchor">#</a> 2.2.3 一方为NAT4，一方为NAT3/NAT4</h4> <p>这种情况下，由于NAT3/NAT4端口受限，而NAT4会改变端口，一般认为不能进行NAT穿透。但目前的研究是，可以使用生日攻击算法等算法来进行端口预测，进而实现打洞。下面简要介绍一种用于在双方皆为对称性NAT的情况下进行NAT穿透的方法[5]。</p> <ol><li><p>环境：终端A和B，NAT A和B，服务器C和D。</p></li> <li><p>终端A和B分别与服务器C、D建立联系，以终端A为例：</p> <p>（1）终端A与服务器C建立联系，服务器C分析NAT A映射的端口号并传回给终端A。</p> <p>（2）终端A向服务器D发送数据包，包含（1）中分析出来的端口号，同时服务器也记录NAT A的映射端口号。服务器D根据比较这两个端口号，可以确定端口号是属于哪种变化趋势的，即递增、递减或随机分配。</p> <p>（3）若端口号变化呈递增或递减的情况，可以通过等差关系获得下一次端口号；若端口号是随机分配的，总的端口号数量为N=65535-1024，由密码学的生日攻击可得，随机猜测439次就可以保证至少一次猜测成功的概率达到95%。因此只要猜测次数足够多，成功几乎是必然的。</p></li> <li><p>NAT A与服务器C、D的交流可以帮助预测一个合适的端口号，由服务器D发送给终端B，终端B依据预测端口号尝试发送数据包给NAT A，此时NAT B将记录这次连接的信息。</p></li> <li><p>NAT B用同样的方式将预测端口号从服务器D发送给终端A，终端A向终端B发送数据包。由于前一步里终端B已经保留了和终端A的连接记录，此次连接会成功。</p></li></ol> <h2 id="第三章-详细设计及实现"><a href="#第三章-详细设计及实现" class="header-anchor">#</a> 第三章 详细设计及实现</h2> <h3 id="_3-1程序语言和实验环境的选择"><a href="#_3-1程序语言和实验环境的选择" class="header-anchor">#</a> 3.1程序语言和实验环境的选择</h3> <p>由于本人对C++语言很熟悉，所以采用C++语言；实验环境使用Ubuntu虚拟机，即使用Linux环境下C++实现socket编程。</p> <h3 id="_3-2-检查网络环境的nat类型"><a href="#_3-2-检查网络环境的nat类型" class="header-anchor">#</a> 3.2 检查网络环境的NAT类型</h3> <img src="/blog/udp/3.png"> <p>由2.2可得，知道自己所处网络环境的NAT类型对该实验是必要的，这里使用NatTypeTester来进行测试，结果如图：</p> <p>NAT类型为FullCone，即完全圆锥型NAT。</p> <p>完全圆锥型NAT对通信的限制要求很小，但不妨碍测试UDP打洞的功能。</p> <h3 id="_3-3-linux的socket编程准备知识"><a href="#_3-3-linux的socket编程准备知识" class="header-anchor">#</a> 3.3 Linux的Socket编程准备知识</h3> <ol><li><p><code>int socket(int family, int type, int protocol)</code> 该函数的功能是创建套接字描述符：</p> <p>（1）family 表示套接字的通信域，决定socket的地址类型，这里使用AF_INET，即IPv4因特网域；</p> <p>（2）type 确定socket的类型，这里使用SOCK_DRGRAM，即UDP连接；</p> <p>（3）protocol 指定协议，这里选择0，即选择type类型对应的默认协议。</p></li> <li><div class="language- line-numbers-mode"><pre class="language-text"><code>struct sockaddr_in{//该结构体用来存储ip和port，位于netinet/in.h
   short sin_family;//AF_INET
   unsigned short sin_port;//存储port
   struct in_addr sin_addr;//参见struct in_addr
   char sin_zero[8];//未使用
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><div class="language- line-numbers-mode"><pre class="language-text"><code>struct in_addr{
unsigned long s_addr;//load with inet_pton()
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p><code>ssize_t sendto(int s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen)</code></p> <p>参数分别表示：socket文件描述符、发送数据的首地址、发送数据的长度、0表示默认、存放目的主机ip地址和端口的信息、to 的长度。</p></li> <li><p><code>ssize_t recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen)</code></p> <p>参数分别表示：socket 文件描述符、接收数据的首地址、可接收数据的最大长度、0表示默认、存放发送方的ip地址和端口、from的长度。</p> <p>这里“存放发送方的IP地址和端口号”部分非常重要，能很方便的存储通信地址信息。</p></li> <li><p><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)</code></p> <p>参数分别表示：套接字描述符、指向特定协议地址结构的指针、地址结构的长度。</p></li></ol> <h3 id="_3-4-服务器"><a href="#_3-4-服务器" class="header-anchor">#</a> 3.4 服务器</h3> <ol><li><p>使用socket函数建立监听socket，得到socket描述符；</p></li> <li><p>使用bind函数将socket描述符与一个地址类型变量绑定</p></li> <li><p>使用recvfrom函数等待获取来自客户端C1和C2的信息。接受到信息时要向对应客户端反馈成功信息；</p></li> <li><p>使用sendto函数将C1和C2的IP和端口号分别转发给对方；</p></li> <li><p>结束close(sock)。</p></li></ol> <h3 id="_3-5-客户端c1"><a href="#_3-5-客户端c1" class="header-anchor">#</a> 3.5 客户端C1</h3> <ol><li><p>使用socket函数建立套接字，得到socket描述符；</p></li> <li><p>使用sendto函数与服务器建立联系，recvfrom函数接收来自服务器的success信息；</p></li> <li><p>继续使用recvfrom函数等待接收来自服务器的信息，里面包含了C2客户端的IP和端口号；</p></li> <li><p>尝试向C2客户端发送数据，由于C2客户端没有与C1客户端的连接记录，所以数据一定发不过去，但C1客户端将保留自己和C2客户端的通信记录；</p></li> <li><p>等待C2客户端的主动连接，连接成功即打洞成功。</p></li></ol> <h3 id="_3-6-客户端c2"><a href="#_3-6-客户端c2" class="header-anchor">#</a> 3.6 客户端C2</h3> <ol><li><p>使用socket函数建立套接字，得到socket描述符；</p></li> <li><p>使用sendto函数与服务器建立联系，recvfrom函数接收来自服务器的success信息；</p></li> <li><p>继续使用recvfrom函数等待接收来自服务器的信息，里面包含了C1客户端的ip和端口号；</p></li> <li><p>直接向C1客户端发送数据，等待来自C1客户端的success信息；</p></li> <li><p>成功接收success，即打洞成功。</p></li></ol> <h3 id="_3-7-一些代码细节"><a href="#_3-7-一些代码细节" class="header-anchor">#</a> 3.7 一些代码细节</h3> <ol><li><p>服务器需要将C1和C2客户端的IP和端口转发给对方，同样，C1和C2客户端需要接收来自服务器的IP和端口信息。IP和端口信息是用netinet/in.h里的sockaddr_in结构体保存的，而sendto和recvfrom函数是对字符串进行发送接收的，因此可以才用变量类型强制转换的方式。设X为发送接收的一个sockaddr_in结构体，在sendto和recvfrom函数里强制转换为(char*)&amp;X即可。结构体和字符串的互相转换可以保证结果无误。</p></li> <li><p>实验过程中可能会遇到各种问题，define一个ERR_EXIT(message)用于出现错误时报错“message”信息。例如：在使用socket函数创建socket描述符时，若返回-1，则ERR_EXIT(“sock error”)。在报错里我们看到sock error即可快速定位是哪个函数出了问题。</p></li> <li><p>服务器、客户端C1和C2各发送接收操作的具体执行步骤：</p> <p>（1） 服务器等待C1客户端的尝试连接，成功后返回发送success；</p> <p>（2） 服务器等待C2客户端的尝试连接，成功后返回发送success；</p> <p>（3） 服务器向C1客户端发送C2客户端的IP和端口号，等待接收来自C1客户端的success反馈；</p> <p>（4） 服务器向C2客户端发送C1客户端的IP和端口号，等待接收来自C2客户端的success反馈；</p> <p>（5） C1客户端向C2客户端发送任意数据包，保留和C2客户端的连接记录，等待接收来自C2客户端的主动连接；</p> <p>（6） C2客户端向C1客户端发送任意数据包，等待接收来自C1客户端的success信息；</p> <p>（7） C1和C2客户端已成功建立连接，打洞结束。</p></li></ol> <p>下面的测试部分将按照该步骤操作。</p> <h2 id="第四章-测试"><a href="#第四章-测试" class="header-anchor">#</a> 第四章 测试</h2> <h3 id="_4-1-实验硬件环境"><a href="#_4-1-实验硬件环境" class="header-anchor">#</a> 4.1 实验硬件环境</h3> <p>实验器材：笔记本电脑</p> <p>计算机配置：</p> <p>设备名称  LAPTOP-C62KUAD9</p> <p>处理器 AMD Ryzen 7 5800H with Radeon Graphics  3.20 GHz</p> <p>系统类型  64 位操作系统, 基于 x64 的处理器</p> <p>CPU内存 16G</p> <h3 id="_4-2-udp打洞客户端编程环境"><a href="#_4-2-udp打洞客户端编程环境" class="header-anchor">#</a> 4.2 UDP打洞客户端编程环境</h3> <p>操作系统：Ubuntu 22.10虚拟机</p> <p>虚拟机配置：</p> <p>内存 4GB</p> <p>处理器内核总数 4</p> <p>网络适配器 NAT模式，固定IP</p> <p>软件平台：</p> <p>开发环境 Visual Studio Code</p> <p>测试环境 Ubuntu 22.10</p> <h3 id="_4-2-udp打洞服务器编程环境"><a href="#_4-2-udp打洞服务器编程环境" class="header-anchor">#</a> 4.2 UDP打洞服务器编程环境</h3> <p>腾讯云轻量服务器：</p> <p>CPU -2核 内存 2GB</p> <p>操作系统：Ubuntu 22.04</p> <p>软件平台：</p> <p>开发环境 vim</p> <h3 id="_4-3-测试页面展示"><a href="#_4-3-测试页面展示" class="header-anchor">#</a> 4.3 测试页面展示</h3> <img src="/blog/udp/4.png"> <p>注意，由于本次实验包含服务器、客户端C1和C2，每个都需要独立编程并运行，其中两个客户端是在虚拟机上运行的，开两个终端分屏展示：</p> <img src="/blog/udp/5.png"> <p>服务器位于云服务器上，单独一个终端页面：</p> <h3 id="_4-4-服务器打开测试"><a href="#_4-4-服务器打开测试" class="header-anchor">#</a> 4.4 服务器打开测试</h3> <p>服务器代码编译后，使用sudo ./指令执行代码：</p> <img src="/blog/udp/6.png"> <p>返回监听端口80，该端口是自己设置的，需要在云服务器里打开对应端口的防火墙。打印到终端方便测试。能看到监听端口，说明前面创建和绑定socket的部分没有问题。</p> <p>此时服务器应当进入等待C1和C2客户端主动来连接的部分，我们再去把C1和C2客户端打开。</p> <h3 id="_4-5-打开c1和c2客户端-向服务器通信测试"><a href="#_4-5-打开c1和c2客户端-向服务器通信测试" class="header-anchor">#</a> 4.5 打开C1和C2客户端，向服务器通信测试</h3> <p>由于服务器代码里，设计的是先监听来自C1客户端的主动连接，所以先打开C1客户端：</p> <img src="/blog/udp/7.png"> <p>可以看到C1客户端收到了来自服务器的接收成功的信息，此时再到服务器的终端页面检查一下：</p> <img src="/blog/udp/8.png"> <p>​	可以看到服务器收到了C1客户端的连接信息，并记录其IP地址和端口号，打印到终端页面里。至此，C1客户端已经将自己的通信地址信息交给服务器了，接下来是C2客户端</p> <img src="/blog/udp/9.png"> <p>​	对应的服务器反馈：</p> <img src="/blog/udp/10.png"> <p>​	在这里我们其实还可以看到端口变化仅为1，说明是递增性。当然实验环境并不是对称性NAT，无需考虑这些。</p> <p>​        C1和C2客户端都已经向服务器保留了自己的IP地址和端口号了，接下来服务器要向C1和C2客户端分别发送对方的IP地址和端口号。前往C1和C2的终端页面查看</p> <img src="/blog/udp/11.png"> <p>​	可以看到C1和C2客户端都从服务器收到了对方的IP地址和端口号，与服务器终端页面里显示的做比较，得出信息交接无误。</p> <p>​	接下来C1和C2客户端要直接尝试互相通信。</p> <h3 id="_4-5-c1和c2客户端打洞测试"><a href="#_4-5-c1和c2客户端打洞测试" class="header-anchor">#</a> 4.5 C1和C2客户端打洞测试</h3> <p>​	代码设计为C1客户端先向C2客户端发送任意数据包，虽然C2客户端会丢弃数据包，但C1客户端会保留与C2客户端的通信记录。下面是C1客户端向C2客户端的初次尝试连接：</p> <img src="/blog/udp/12.png"> <p>​	其中cB是保存的C2客户端的sockaddr_in结构体，即C2客户端的IP地址和端口号。</p> <p>​	C1客户端发送数据后直接进入等待阶段，等待来自C2客户端的主动连接：</p> <img src="/blog/udp/13.png"> <p>​	上面代码里使用while(1)循环来持续接收信息，若接收到信息就把信息打印出来，并向C2客户端反馈接收成功。</p> <p>​	C2客户端这边，由于C1客户端已经来打洞了，所以直接尝试连接C1客户端  :</p> <img src="/blog/udp/14.png"> <p>​	同样使用while(1)循环来持续向C1客户端发送数据及尝试接收来自C1客户端的success反馈。若成功收到，打印信息到终端。
​	测试结果入下图</p> <img src="/blog/udp/15.png"> <p>C1和C2客户端的打洞成功，接下来测试直接通信。</p> <h3 id="_4-6-c1和c2客户端直接通信测试"><a href="#_4-6-c1和c2客户端直接通信测试" class="header-anchor">#</a> 4.6 C1和C2客户端直接通信测试</h3> <p>​	在C1客户端的终端里写下任意字符串，回车发送：</p> <img src="/blog/udp/16.png"> <p>​	接下来在C2客户端的终端里直接回车接收：</p> <img src="/blog/udp/17.png"> <p>可以看到C1和C2客户端可以直接通信，打洞成功。</p> <h2 id="代码"><a href="#代码" class="header-anchor">#</a> 代码</h2> <h3 id="服务器"><a href="#服务器" class="header-anchor">#</a> 服务器：</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>//服务器
//设计为A,B两个客户端把各自的信息（id,port）发给服务器，服务器再转发给对方
//接着A向B通信，A处留下映射表，B再向A通信，成功打洞
#include&lt;bits/stdc++.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;arpa/inet.h&gt;
using namespace std;
#define ERR_EXIT(message)do{ perror(message);exit(EXIT_FAILURE);}while(0)//用于报错
#define PORT 80
#define BUFF_SIZE 100

struct sockaddr_in C[3];//用来保存C1,C2的info(ip和port)
char SUCCESS[]=&quot;successful&quot;;

//获取C[id]的ip和port
void getInfoFromClient(int sock, int id){
    char revBuff[BUFF_SIZE];
    socklen_t sock_len=sizeof(C[id]);

    //接收C[id]ip和port,方便获取信息
    if(recvfrom(sock,revBuff,sizeof(revBuff),0,(struct sockaddr*)&amp;C[id],&amp;sock_len)==-1)ERR_EXIT(&quot;recv error&quot;);
    cout&lt;&lt;&quot;recv message From C&quot;&lt;&lt;id&lt;&lt;&quot; ip:&quot;&lt;&lt;inet_ntoa(C[id].sin_addr)&lt;&lt;&quot; port:&quot;&lt;&lt;ntohs(C[id].sin_port)&lt;&lt;endl;

    //发送接收成功的信息
    sendto(sock,SUCCESS,sizeof(SUCCESS),0,(struct sockaddr*)&amp;C[id],sock_len);
    return;
}

//将C1,C2的信息发送给对方
void sendInfoToClient(int sock){
    socklen_t sock_len=sizeof(C[1]);
    char buff[BUFF_SIZE];

    //注意这里强制转化为char*
    sendto(sock,(char *)&amp;C[1],sizeof(buff),0,(struct sockaddr*)&amp;C[2],sock_len);
    sendto(sock,(char *)&amp;C[2],sizeof(buff),0,(struct sockaddr*)&amp;C[1],sock_len);

}
int main(){
    struct sockaddr_in s;
    int sock;

    
    //建立监听socket
    if((sock=socket(AF_INET,SOCK_DGRAM,0))==-1)ERR_EXIT(&quot;socket error&quot;);
    memset(&amp;s,0,sizeof(s));
    s.sin_family=AF_INET;
    s.sin_port=htons(PORT);
    s.sin_addr.s_addr=INADDR_ANY;
   
    socklen_t sock_len = sizeof(s);
    
    cout&lt;&lt;&quot;监听端口：&quot;&lt;&lt;PORT&lt;&lt;endl;
    //把socket描述符和一个地址类型变量绑定
    if(bind(sock,(struct sockaddr*)&amp;s,sock_len)==-1)ERR_EXIT(&quot;bind error&quot;);
    

    //获取C1,C2的信息
    getInfoFromClient(sock,1);
    getInfoFromClient(sock,2);

    //将C1,C2的信息发送给对方
    sendInfoToClient(sock);

    close(sock);

    return 0;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br></div></div><hr> <h3 id="客户端c1"><a href="#客户端c1" class="header-anchor">#</a> 客户端C1</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>//客户端A
#include&lt;bits/stdc++.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;arpa/inet.h&gt;
using namespace std;
#define ERR_EXIT(message)do{ perror(message);exit(EXIT_FAILURE);}while(0)
#define SERVER_PORT 80
#define PORT 8887
#define BUFF_SIZE 100


struct sockaddr_in cB;//客户端B的scokaddr_in
struct sockaddr_in server;//服务器的sockaddr_in

//向服务器发送自己的ip和port
void sentInfoToServer(int sock,socklen_t sock_len){
    char revBuff[BUFF_SIZE];
    char sendBuff[BUFF_SIZE]=&quot;conects server&quot;;

    //把自己的ip和port发送给服务器
    sendto(sock,sendBuff,sizeof(sendBuff),0,(struct sockaddr*)&amp;server,sock_len);

    //接收服务器的反馈信息
    if(recvfrom(sock,revBuff,sizeof(revBuff),0,(struct sockaddr*)&amp;server,&amp;sock_len)==-1)ERR_EXIT(&quot;recv1 error&quot;);
    cout&lt;&lt;&quot;recv message From server:&quot;&lt;&lt;revBuff&lt;&lt;endl;

    //接收服务器发来的客户端B的ip和port
    if(recvfrom(sock,(char *)&amp;cB,sizeof(cB),0,(struct sockaddr*)&amp;server,&amp;sock_len)==-1)ERR_EXIT(&quot;recv error&quot;);
    cout&lt;&lt;&quot;recv cB'info From S: ip:&quot;&lt;&lt;inet_ntoa(cB.sin_addr)&lt;&lt;&quot; port:&quot;&lt;&lt;ntohs(cB.sin_port)&lt;&lt;endl;
}
//发送信息给客户端B
void sentMessageToC(int sock,socklen_t sock_len){
    char sendBuff[BUFF_SIZE]=&quot;hello cB&quot;;
    char recvBuff[BUFF_SIZE];

    //第一次尝试打洞，目的是给自己留下映射表以便接下来cB主动连接自己. 这里的cB会因为没有cA的映射表而丢弃cA的发送信息
    sendto(sock,sendBuff,sizeof(sendBuff),0,(struct sockaddr*)&amp;cB,sock_len);

   //等待cB的连接
   while(1){
        //如果成功接收到了，告诉cB一声
        if(recvfrom(sock,recvBuff,sizeof(recvBuff),0,(struct sockaddr*)&amp;cB,&amp;sock_len)!=-1){
            cout&lt;&lt;&quot;recv cB's message:&quot;&lt;&lt;recvBuff&lt;&lt;endl;
            sendto(sock,sendBuff,sizeof(sendBuff),0,(struct sockaddr*)&amp;cB,sizeof(cB));
            break;
        }    
   }

   //打洞成功，可以通信
   while(1){
        memset(recvBuff,0,sizeof(recvBuff));
        memset(sendBuff,0,sizeof(sendBuff));

        //接收cB的连接
        if(recvfrom(sock,recvBuff,sizeof(recvBuff),0,(struct sockaddr*)&amp;cB,&amp;sock_len)==-1)ERR_EXIT(&quot;recv error&quot;);
        cout&lt;&lt;&quot;recv message From cB:&quot;&lt;&lt;recvBuff&lt;&lt;endl;

        //向cB发送信息
        if(fgets(sendBuff,sizeof(sendBuff),stdin)!=NULL)
            sendto(sock,sendBuff,sizeof(sendBuff),0,(struct sockaddr*)&amp;cB,sock_len);
   }
   close(sock);
}
int main(){
    int sock;
    if((sock=socket(AF_INET,SOCK_DGRAM,0))==-1)ERR_EXIT(&quot;sock error&quot;);
    memset(&amp;server,0,sizeof(server));

    server.sin_family=AF_INET;
    server.sin_port=htons(SERVER_PORT);
    server.sin_addr.s_addr=inet_addr(&quot;162.14.83.124&quot;);

    socklen_t sock_len=sizeof(server);

    sentInfoToServer(sock,sock_len);
    sentMessageToC(sock,sock_len);

    return 0;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br></div></div><hr> <h3 id="客户端c2"><a href="#客户端c2" class="header-anchor">#</a> 客户端C2</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>//客户端B
#include&lt;bits/stdc++.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;arpa/inet.h&gt;
#include&lt;unistd.h&gt;
using namespace std;
#define ERR_EXIT(message)do{ perror(message);exit(EXIT_FAILURE);}while(0)
#define SERVER_PORT 80
#define PORT 8886
#define BUFF_SIZE 100


struct sockaddr_in cA;//客户端A的scokaddr_in
struct sockaddr_in server;//服务器的sockaddr_in

//向服务器发送自己的ip和port
void sentInfoToServer(int sock,socklen_t sock_len){
    char revBuff[BUFF_SIZE];
    char sendBuff[BUFF_SIZE]=&quot;conects server&quot;;

    //把自己的ip和port发送给服务器
    sendto(sock,sendBuff,sizeof(sendBuff),0,(struct sockaddr*)&amp;server,sock_len);

    //接收服务器的反馈信息
    if(recvfrom(sock,revBuff,sizeof(revBuff),0,(struct sockaddr*)&amp;server,&amp;sock_len)==-1)ERR_EXIT(&quot;recv1 error&quot;);
    cout&lt;&lt;&quot;recv message From server:&quot;&lt;&lt;revBuff&lt;&lt;endl;

    //接收服务器发来的客户端B的ip和port
    if(recvfrom(sock,(char *)&amp;cA,sizeof(cA),0,(struct sockaddr*)&amp;server,&amp;sock_len)==-1)ERR_EXIT(&quot;recv error&quot;);
    cout&lt;&lt;&quot;recv cA'info From S: ip:&quot;&lt;&lt;inet_ntoa(cA.sin_addr)&lt;&lt;&quot; port:&quot;&lt;&lt;ntohs(cA.sin_port)&lt;&lt;endl;
}

//发送信息给客户端A
void sentMessageToC(int sock, socklen_t sock_len){
    char sendBuff[BUFF_SIZE]=&quot;hello cA&quot;;
    char recvBuff[BUFF_SIZE];

    //由于是cA先来连接，直接就可以发送信息给cA,cA应该有对应的映射表了
   //尝试连接cA
   sleep(5);//sleep一下，等待cA连接
   while(1){
        sendto(sock,sendBuff,sizeof(sendBuff),0,(struct sockaddr*)&amp;cA,sock_len);
        //如果接收到cA的信息，说明cA已经连接上了
        if(recvfrom(sock,recvBuff,sizeof(recvBuff),0,(struct sockaddr*)&amp;cA,&amp;sock_len)!=-1){
            cout&lt;&lt;&quot;cA is connected&quot;&lt;&lt;endl;
            break;
        }
   }

   //正常通信
   while(1){
        memset(recvBuff,0,sizeof(recvBuff));
        memset(sendBuff,0,sizeof(sendBuff));

        //向cA发送信息
        if(fgets(sendBuff,sizeof(sendBuff),stdin)!=NULL)
            sendto(sock,sendBuff,sizeof(sendBuff),0,(struct sockaddr*)&amp;cA,sock_len);
        
        //接收cA的连接
        if(recvfrom(sock,recvBuff,sizeof(recvBuff),0,(struct sockaddr*)&amp;cA,&amp;sock_len)==-1)ERR_EXIT(&quot;recv error&quot;);
        cout&lt;&lt;&quot;recv message From cA:&quot;&lt;&lt;recvBuff&lt;&lt;endl;


   }
   close(sock);
}
int main(){
    int sock;
    if((sock=socket(AF_INET,SOCK_DGRAM,0))==-1)ERR_EXIT(&quot;sock error&quot;);
    memset(&amp;server,0,sizeof(server));

    server.sin_family=AF_INET;
    server.sin_port=htons(SERVER_PORT);
    server.sin_addr.s_addr=inet_addr(&quot;162.14.83.124&quot;);

    socklen_t sock_len=sizeof(server);

    sentInfoToServer(sock,sock_len);
    sentMessageToC(sock,sock_len);

    return 0;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br></div></div></div></article> <!----></div></main> <aside class="aside" data-v-b3fda33c data-v-b3fda33c><div class="info-card main-div" data-v-1311ce9e data-v-b3fda33c><div class="info-card-header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/blog/HP/back.JPG);" data-v-1311ce9e><img src="/blog/HP/logo-nav.png" alt="Akejyo" class="info-avatar" data-v-1311ce9e></div> <div class="info-card-body" data-v-1311ce9e><section class="info-name" data-v-1311ce9e>
      Akejyo
    </section> <section class="info-desc" data-v-1311ce9e>乘物以游心</section> <section class="info-contact" data-v-1311ce9e><!----> <!----> <section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-email" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          987383393@qq.com
        </span></span></section></section></div> <div class="info-card-footer" data-v-1311ce9e><p class="footer-sns-link" data-v-1311ce9e><a target="_blank" href="https://space.bilibili.com/252038787?spm_id_from=333.1007.0.0" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-bilibili" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" href="https://github.com/akejyo" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-github" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" href="https://www.zhihu.com/people/yu-pigeon" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-zhihu" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a></p></div></div> <div class="post-toc main-div aside-toc" style="position:relative;top:0;width:0px;" data-v-b3fda33c><h4>- CATALOG</h4> <div class="post-nav-toc"><ul><li><a href="/blog/posts/2023/05/07/udp.html#_1-1-nat简介">1.1 NAT简介</a><ul><li><a href="/blog/posts/2023/05/07/udp.html#_1-2-p2p简介">1.2 P2P简介</a></li><li><a href="/blog/posts/2023/05/07/udp.html#_1-3-udp">1.3 UDP</a></li></ul></li><li><a href="/blog/posts/2023/05/07/udp.html#第二章-系统分析">第二章 系统分析</a><ul><li><a href="/blog/posts/2023/05/07/udp.html#_2-1-nat的类型分析">2.1 NAT的类型分析</a></li><li><a href="/blog/posts/2023/05/07/udp.html#_2-2-udp打洞方式分析">2.2 UDP打洞方式分析</a></li></ul></li><li><a href="/blog/posts/2023/05/07/udp.html#第三章-详细设计及实现">第三章 详细设计及实现</a><ul><li><a href="/blog/posts/2023/05/07/udp.html#_3-1程序语言和实验环境的选择">3.1程序语言和实验环境的选择</a></li><li><a href="/blog/posts/2023/05/07/udp.html#_3-2-检查网络环境的nat类型">3.2 检查网络环境的NAT类型</a></li><li><a href="/blog/posts/2023/05/07/udp.html#_3-3-linux的socket编程准备知识">3.3 Linux的Socket编程准备知识</a></li><li><a href="/blog/posts/2023/05/07/udp.html#_3-4-服务器">3.4 服务器</a></li><li><a href="/blog/posts/2023/05/07/udp.html#_3-5-客户端c1">3.5 客户端C1</a></li><li><a href="/blog/posts/2023/05/07/udp.html#_3-6-客户端c2">3.6 客户端C2</a></li><li><a href="/blog/posts/2023/05/07/udp.html#_3-7-一些代码细节">3.7 一些代码细节</a></li></ul></li><li><a href="/blog/posts/2023/05/07/udp.html#第四章-测试">第四章 测试</a><ul><li><a href="/blog/posts/2023/05/07/udp.html#_4-1-实验硬件环境">4.1 实验硬件环境</a></li><li><a href="/blog/posts/2023/05/07/udp.html#_4-2-udp打洞客户端编程环境">4.2 UDP打洞客户端编程环境</a></li><li><a href="/blog/posts/2023/05/07/udp.html#_4-2-udp打洞服务器编程环境">4.2 UDP打洞服务器编程环境</a></li><li><a href="/blog/posts/2023/05/07/udp.html#_4-3-测试页面展示">4.3 测试页面展示</a></li><li><a href="/blog/posts/2023/05/07/udp.html#_4-4-服务器打开测试">4.4 服务器打开测试</a></li><li><a href="/blog/posts/2023/05/07/udp.html#_4-5-打开c1和c2客户端-向服务器通信测试">4.5 打开C1和C2客户端，向服务器通信测试</a></li><li><a href="/blog/posts/2023/05/07/udp.html#_4-5-c1和c2客户端打洞测试">4.5 C1和C2客户端打洞测试</a></li><li><a href="/blog/posts/2023/05/07/udp.html#_4-6-c1和c2客户端直接通信测试">4.6 C1和C2客户端直接通信测试</a></li></ul></li><li><a href="/blog/posts/2023/05/07/udp.html#代码">代码</a><ul><li><a href="/blog/posts/2023/05/07/udp.html#服务器">服务器：</a></li><li><a href="/blog/posts/2023/05/07/udp.html#客户端c1">客户端C1</a></li><li><a href="/blog/posts/2023/05/07/udp.html#客户端c2">客户端C2</a></li></ul></li></ul></div></div></aside></div> <footer class="footer" data-v-7f2e4136><p class="footer-sns-link"><a target="_blank" href="https://space.bilibili.com/252038787?spm_id_from=333.1007.0.0" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-bilibili"></use></svg></span></a><a target="_blank" href="https://github.com/akejyo" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-github"></use></svg></span></a><a target="_blank" href="https://www.zhihu.com/people/yu-pigeon" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-zhihu"></use></svg></span></a></p> <div class="copyright"><span id="custom">Copyright &copy; Akejyo 2022 <br /> 
          Theme By <a href="https://www.vuepress.cn/" target="_blank">VuePress</a>
          | <a href="https://www.github.com/youdeliang/" target="_blank">youdeliang</a></span> <iframe src="https://github.com/Akejyo/blog" frameborder="0" scrolling="0" width="80px" height="20px" class="footer-btn" style="margin-left: 2px; margin-bottom:-5px;"></iframe></div></footer></div><div class="global-ui"><!----><!----><canvas id="vuepress-canvas-cursor"></canvas><!----><div></div><!----></div></div>
    <script src="/blog/assets/js/app.10530e5b.js" defer></script><script src="/blog/assets/js/7.3944018b.js" defer></script><script src="/blog/assets/js/71.2c3d7701.js" defer></script><script src="/blog/assets/js/4.bcd292e7.js" defer></script>
  </body>
</html>
